#pragma kernel CSWorley
#pragma kernel CSNormalize

static const int numThreads = 8;
static const int minMaxAccuracy = 10000000;


uint resolution;
bool invertNoise;
float4 channelMask;
float persistence;
int tile;

int gridSizeA;
int gridSizeB;
int gridSizeC;

RWTexture3D<float4> Result;
RWStructuredBuffer<int> minMax;
StructuredBuffer<float3> pointsA;
StructuredBuffer<float3> pointsB;
StructuredBuffer<float3> pointsC;


static const int3 offsets[] =
{
    // centre
    int3(0, 0, 0),
    // front face
    int3(0, 0, 1),
    int3(-1, 1, 1),
    int3(-1, 0, 1),
    int3(-1, -1, 1),
    int3(0, 1, 1),
    int3(0, -1, 1),
    int3(1, 1, 1),
    int3(1, 0, 1),
    int3(1, -1, 1),
    // back face
    int3(0, 0, -1),
    int3(-1, 1, -1),
    int3(-1, 0, -1),
    int3(-1, -1, -1),
    int3(0, 1, -1),
    int3(0, -1, -1),
    int3(1, 1, -1),
    int3(1, 0, -1),
    int3(1, -1, -1),
    // ring around centre
    int3(-1, 1, 0),
    int3(-1, 0, 0),
    int3(-1, -1, 0),
    int3(0, 1, 0),
    int3(0, -1, 0),
    int3(1, 1, 0),
    int3(1, 0, 0),
    int3(1, -1, 0)
};

float worley(StructuredBuffer<float3> points, int gridSize, float3 uv)
{
    uv = (uv * tile) % 1;
    float minDist = 2;
    int3 cellID = floor(uv * gridSize);

    int realGridSize = gridSize + 2;

    [unroll(27)]
    for (int cellOffsetIndex = 0; cellOffsetIndex < 27; cellOffsetIndex++)
    {
        int3 adjID = cellID + 1 + offsets[cellOffsetIndex];
        int adjCellIndex = adjID.x + realGridSize * (adjID.y + realGridSize * adjID.z);

        float3 diff = uv - points[adjCellIndex];
        minDist = min(minDist, dot(diff, diff));
    }
    return sqrt(minDist);
}

[numthreads(numThreads,numThreads,numThreads)]
void CSWorley(uint3 id : SV_DispatchThreadID)
{
    float3 uvw = id / (float)resolution;
    float layerA = worley(pointsA, gridSizeA, uvw);
    float layerB = worley(pointsB, gridSizeB, uvw);
    float layerC = worley(pointsC, gridSizeC, uvw);

    float noiseSum = layerA + (layerB * persistence) + (layerC * persistence * persistence);
    float maxVal = 1 + (persistence) + (persistence * persistence);

    noiseSum /= maxVal;

    if (invertNoise)
    {
        noiseSum = 1 - noiseSum;
    }

    // keep track of min max (using int to support atomic operation)
    int val = (int)(noiseSum * minMaxAccuracy);
    InterlockedMin(minMax[0], val);
    InterlockedMax(minMax[1], val);

    // Store result in specified channel of texture
    Result[id] = Result[id] * (1 - channelMask) + noiseSum * channelMask;
}


[numthreads(numThreads,numThreads,numThreads)]
void CSNormalize(uint3 id : SV_DispatchThreadID)
{
    float minVal = (float)minMax[0] / minMaxAccuracy;
    float maxVal = (float)minMax[1] / minMaxAccuracy;
    float4 normalized = (Result[id] - minVal) / (maxVal - minVal);

    Result[id] = Result[id] * (1 - channelMask) + normalized * channelMask;
}
